<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        text {
            font-family: 'Yanone Kaffeesatz', sans-serif;
            font-size: 11px;
            text-anchor: middle;
            alignment-baseline: middle;
            fill: white;
            font-weight: 100
        }
    </style>
</head>
<body>
<script>
    const width = 800;
    const height = 800;
    const margin = 80;
    const svg = d3.select('body').append('svg').attr('width',width).attr('height',height);
    const chart = svg.append('g').attr('transform', `translate(${[width/2 + margin/4, height/2 + margin/4]})`);
    const radius = height/2 - margin/2;

    const color = d3.scaleSequential(d3.interpolateRainbow).domain([0,13]);

    // Using gradient ribbons - see tutorial:
    // https://www.visualcinnamon.com/2016/06/orientation-gradient-d3-chord-diagram.html

    function gradientId(d){
        return "grad-" + d.source.index + "-" + d.target.index;
    }
    function gradient(d) {
        return "url(#" + gradientId(d) + ")";
    }
    function makeGradients(chords) {
        var grads = svg.append("defs")
                .selectAll("linearGradient")
                .data(chords)
                .enter()
                .append("linearGradient")
                .attr("id", d => gradientId(d))
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("x1", function(d) {
                    return radius * Math.cos((d.source.endAngle-d.source.startAngle) / 2 + d.source.startAngle - Math.PI/2);
                })
                .attr("y1", function(d) {
                    return radius * Math.sin((d.source.endAngle-d.source.startAngle) / 2 + d.source.startAngle - Math.PI/2);
                })
                .attr("x2", function(d) {
                    return radius * Math.cos((d.target.endAngle-d.target.startAngle) / 2 + d.target.startAngle - Math.PI/2);
                })
                .attr("y2", function(d) {
                    return radius * Math.sin((d.target.endAngle-d.target.startAngle) / 2 + d.target.startAngle - Math.PI/2);
                })

        // set the starting color (at 0%)
        grads.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", d => color(d.target.index))
                .attr("stop-opacity", 1);

        grads.append("stop")
                .attr("offset", "50%")
                .attr("stop-color", function(d) {
                    const tch = d3.hsl(color(d.target.index));
                    const sch = d3.hsl(color(d.target.index));
                    return d3.hsl((tch.h + sch.h)/2, (tch.s+sch.s)/2, (tch.l+sch.l)/2);
                })
                .attr("stop-opacity", 0.3);

        //set the ending color (at 100%)
        grads.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", d =>color(d.source.index))
                .attr("stop-opacity", 1);

        return grads;
    }
    //

    d3.csv("../Data/sa_borders.csv", function(row) {
        const line = [];
        for(key in row) {
            if(isNaN(row[key])) continue;
            const obj = {
                value: +row[key] ,
                source: row.Country,
                target: key
            }
            line.push(obj);
        }
        return line.filter(d => d.value != 0);
    }).then(function(data) {
        const links = d3.merge(data).filter(d => d.target != 'Atlantic' && d.target != 'Pacific');
        const groups = d3.nest()
                         .key(d => d.source)
                         .key(d => d.target)
                         .rollup(d => d[0].value)
                         .map(links);
        const columns = data.columns
                            .filter((d,i) => i>0)
                            .filter(d => d != 'Atlantic' && d != 'Pacific')

        const matrix = makeMatrix(columns, groups);

        draw(columns.map(d => d === 'French Guyana' ? 'F. Guyana' : d), matrix);
    });

    function makeMatrix(columns, groups) {
        const matrix = [];
        columns.forEach(function(r) {
            const row = [];
            columns.forEach(function(c) {
                let value = undefined;
                let target = groups.get(c);
                if(target) {
                    value = groups.get(c).get(r);
                }
                if(!value) {
                    target = groups.get(r);
                    if(target) {
                        value = groups.get(r).get(c);
                    }
                }
                if(!value) {
                    row.push(0);
                } else {
                    row.push(value);
                }
            });
            matrix.push(row);
        })
        return matrix;
    }

    function draw(headers, matrix) {
        console.log(matrix);

        const chord = d3.chord()
                        .padAngle(.02)
                        .sortGroups((a,b) => d3.descending(a,b))
        const chords = chord(matrix);

        //
        const grads = makeGradients(chords);
        //

        const ribbon = d3.ribbon().radius(radius);

        chart.selectAll('path.ribbon')
                .data(chords)
                .enter().append('path').attr('class','ribbon')
                .attr('d', ribbon)
                .attr('stroke', 'black')
                .attr('stroke-width', .2)
                .style("fill", d => gradient(d));

        const arc = d3.arc().innerRadius(radius).outerRadius(radius+20);

        chart.selectAll('path.arc')
                .data(chords.groups)
                .enter().append('path').attr('class','arc')
                .attr('d', arc)
                .attr('fill', d => color(d.index));

        chart.selectAll('text')
                .data(chords.groups)
                .enter().append('text')
                .attr('x', d => arc.centroid(d)[0])
                .attr('y', d => arc.centroid(d)[1])
                .text(d => headers[d.index])
                .attr('transform',d => `rotate(${(arc.endAngle()(d) + arc.startAngle()(d))*90/Math.PI},${arc.centroid(d)})`);
    }
</script>

</body>
</html>