<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="../JavaScript/arc.js"></script>
    <style>
        text {
            font-family: 'Yanone Kaffeesatz', sans-serif;
            font-size: 12px;
            alignment-baseline: middle;
            text-anchor: middle;
            fill: white;
        }
    </style>
</head>
<body>
<script>
    const width = 1000;
    const height = 800;
    const margin = 100;

    const nodes = [];
    const links = [];

    const scaleWidth = d3.scaleLinear().range([1,60]);
    const scaleOpacity = d3.scaleSqrt().range([.9,.3]);
    const colors = ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928','#ffed6f','black','#e7298a'];

    d3.csv("../Data/sa_borders.csv", function(row) {
        nodes.push({node: row.Country})
        return row;
    }).then(function(data) {
        data.forEach(function(d) {
            for(const key in d) {
                if(key != 'Country' && +d[key]) {
                    const link = {};
                    link.value = +d[key];
                    link.source = nodes.map(n => n.node).indexOf(d.Country);
                    link.target = nodes.map(n => n.node).indexOf(key);
                    links.push(link);
                }
            }
        });

        console.log(nodes, links)

        scaleWidth.domain(d3.extent(links, d => d.value))
        scaleOpacity.domain(d3.extent(links, d => d.value))

        const svg = d3.select("body").append("svg").attr("width",width).attr("height",height);
        const chart = svg.append("g").attr("transform", `translate(${[width * .5,height * .5]})`);

        const sim = d3.forceSimulation(nodes);
        sim.force('center', d3.forceCenter());
        sim.force('manyBody', d3.forceManyBody().strength(-600));
        sim.force('link', d3.forceLink(links).iterations(2).distance(100))
        sim.force('collision', d3.forceCollide(d => Math.random() * 40 + 70))

        for(let i = 0; i < 300; i++) { sim.tick(); }
        draw(chart,data);
        sim.stop();
    });

    function draw(chart, data) {
        chart.selectAll('line')
                .data(links).enter()
                .append('line')
                .attr('x1', d => d.source.x)
                .attr('x2', d => d.target.x)
                .attr('y1', d => d.source.y)
                .attr('y2', d => d.target.y)
                .attr('fill', 'none')
                .attr('stroke', 'black')
                .attr('opacity', d => scaleOpacity(d.value))
                .attr('stroke-width', d => scaleWidth(d.value))

        chart.selectAll('circle')
                .data(nodes).enter()
                .append('circle')
                .attr('r', d => 30)
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('fill', (d,i) => colors[i])
                .attr('stroke', 'black')
                .attr('stroke-width', .5)

        chart.selectAll('text')
                .data(nodes).enter()
                .append('text')
                .text(d => d.node)
                .attr('x', d => d.x)
                .attr('y', d => d.y)
                .style('fill', (d,i) => contrast(colors[i]))
                .style("font-size", function(d) {
                    const size = Math.min(70, 62 / this.getComputedTextLength() * 9);
                    return size > 7 ? size : 0;
                })
    }

    function contrast(color) {
        const c = d3.rgb(color);
        return (c.r * 0.299 + c.g * 0.587 + c.b * 0.114) > 130 ? 'black' : 'white';
    }


</script>
</body>
</html>