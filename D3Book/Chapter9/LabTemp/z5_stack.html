<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .graticule {
            fill: none;
            stroke: #777;
            stroke-width: .5px;
            stroke-opacity: .5;
        }
    </style>
</head>
<body>
<script>
    function createMap() {
        var width = 400,
                height = 300,
                scale = 100,
                lastX = 0,
                lastY = 0,
                origin = {
                    x: 55,
                    y: -40
                };

        var svg = d3.select('body').append('svg')
                .style('width', 400)
                .style('height', 300)
                .style('border', '1px lightgray solid')

        var projection = d3.geoOrthographic()
                .scale(scale)
                .translate([width / 2, height / 2])
                .rotate([origin.x, origin.y])
                .center([0, 0])
                .clipAngle(90);

        var geoPath = d3.geoPath()
                .projection(projection);

        var graticule = d3.geoGraticule();

        // zoom AND rotate
        svg.call(d3.zoom().on('zoom', zoomed));

        // code snippet from http://stackoverflow.com/questions/36614251
        var λ = d3.scaleLinear()
                .domain([-width, width])
                .range([-180, 180])

        var φ = d3.scaleLinear()
                .domain([-height, height])
                .range([90, -90]);

        svg.append('path')
                .datum(graticule)
                .attr('class', 'graticule')
                .attr('d', geoPath);

        function zoomed() {
            var transform = d3.event.transform;
            var r = {
                x: λ(transform.x),
                y: φ(transform.y)
            };
            var k = Math.sqrt(100 / projection.scale());
            if (d3.event.sourceEvent.wheelDelta) {
                projection.scale(scale * transform.k)
                transform.x = lastX;
                transform.y = lastY;
            } else {
                projection.rotate([origin.x + r.x, origin.y + r.y]);
                lastX = transform.x;
                lastY = transform.y;
            }
            updatePaths(svg, graticule, geoPath);
        };

    };

    function updatePaths(svg, graticule, geoPath) {
        svg.selectAll('path.graticule').datum(graticule).attr('d', geoPath);
    };

    createMap();
</script>
</body>
</html>